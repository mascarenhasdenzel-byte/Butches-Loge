<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Butch Heb d Frässe — Einvernehmlich</title>
<style>
  :root{
    --bg:#f6f7fb; --card:#ffffff; --accent:#4b7bec; --muted:#6b7280;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  body{margin:0;background:var(--bg);color:#111;display:flex;min-height:100vh;align-items:flex-start;justify-content:center;padding:32px;}
  .app{width:100%;max-width:980px}
  header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
  .logo{width:56px;height:56px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#6f9dfb);display:flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:18px}
  h1{margin:0;font-size:20px}
  .grid{display:grid;grid-template-columns:1fr 360px;gap:18px}
  .card{background:var(--card);padding:16px;border-radius:12px;box-shadow:0 6px 18px rgba(16,24,40,0.06)}
  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
  input[type="text"]{width:100%;padding:10px;border-radius:8px;border:1px solid #e6e9ef;font-size:14px}
  button{background:var(--accent);color:white;border:0;padding:10px 12px;border-radius:8px;font-weight:600;cursor:pointer}
  .muted{color:var(--muted);font-size:13px}
  .section{margin-bottom:14px}
  ul{padding-left:18px;margin:6px 0}
  .friend{display:flex;align-items:center;justify-content:space-between;padding:8px 0;border-bottom:1px dashed #eef2ff}
  .friend:last-child{border-bottom:0}
  .small{font-size:13px}
  .btn-ghost{background:transparent;color:var(--accent);border:1px solid #e6ecff;padding:6px 8px;border-radius:8px}
  .challenge-card{border-left:4px solid #cfe0ff;padding:10px;border-radius:8px;background:#fafbff;margin-bottom:8px}
  .timer{font-weight:700}
  .danger{color:#e63946}
  footer{margin-top:18px;font-size:12px;color:var(--muted)}
  .notice{background:#fff8e6;border-radius:8px;padding:10px;border:1px solid #fff0c7;color:#7a5f00;margin-bottom:12px}
</style>
</head>
<body>
  <div class="app">
    <header>
      <div class="logo">QC</div>
      <div>
        <h1>Butch bis Still — (einvernehmlich)</h1>
        <div class="muted">Jeder muss zustimmen. Zwei mal pro Monat pro Person.</div>
      </div>
    </header>

    <div class="grid">
      <main class="card">
        <div class="section" id="authSection">
          <label>Dein Nutzername</label>
          <div style="display:flex;gap:8px">
            <input id="usernameInput" type="text" placeholder="z. B. max" />
            <button id="loginBtn">Anmelden</button>
          </div>
          <div class="muted small" style="margin-top:8px">Die App speichert lokal (Demo). Keine Konten, kein Server.</div>
        </div>

        <div id="appArea" style="display:none">
          <div class="notice">
            Diese Demo ist für **einvernehmliches** Fresse halten gedacht. Der Empfänger muss annehmen.
          </div>

          <div class="section">
            <label>Freunde / Kontakte</label>
            <div style="display:flex;gap:8px">
              <input id="friendInput" type="text" placeholder="Freund hinzufügen (Nutzername)" />
              <button id="addFriendBtn">Hinzufügen</button>
            </div>
            <div id="friendsList" style="margin-top:10px"></div>
          </div>

          <div class="section">
            <label>Stille erstellen (5 Minuten)</label>
            <div class="muted small">Du kannst pro Kalendermonat maximal 2 mal jemanden die Fresse halten lassen.</div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <select id="friendSelect" style="flex:1;padding:10px;border-radius:8px;border:1px solid #e6e9ef"></select>
              <button id="challengeBtn">Seelenfrieden erhalten</button>
            </div>
            <div id="createMsg" class="muted small" style="margin-top:8px"></div>
          </div>

          <div class="section">
            <label>Ausstehende Einladungen</label>
            <div id="invitations"></div>
          </div>

          <div class="section">
            <label>Aktive Stille</label>
            <div id="activeChallenges"></div>
          </div>

          <div class="section">
            <label>History (letzte Aktionen)</label>
            <div id="history" class="muted small"></div>
          </div>
        </div>
      </main>

      <aside class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
          <div>
            <div class="muted small">Angemeldet als</div>
            <div id="meName" style="font-weight:700">—</div>
          </div>
          <div>
            <button id="logoutBtn" class="btn-ghost" style="display:none">Abmelden</button>
          </div>
        </div>

        <div class="section">
          <label>Monatliche Statistik</label>
          <div id="stats" class="muted small">—</div>
        </div>

        <div class="section">
          <label>Regeln / Consent</label>
          <ul class="muted small">
            <li>Alle Teilnehmenden müssen zustimmen.</li>
            <li>Max. 2 Mal Fresse Halten pro Monat pro Person.</li>
            <li>Bei Missbrauch: weinen gehen.</li>
          </ul>
        </div>

        <div class="section">
          <label>Demo-Hinweis</label>
          <div class="muted small">Dies ist eine lokale Demo.</div>
        </div>
      </aside>
    </div>

    <footer class="muted">© Butch heb d frässe — Demo • Nur mit Zustimmung</footer>
  </div>

<script>
/*
  Simple localStorage-backed demo.
  Data model:
  store = {
    users: { username: { username, friends: [], invites:[], challenges:[] } },
    currentUser: username
  }
*/
const STORE_KEY = 'qc_demo_v1';

function loadStore(){
  const raw = localStorage.getItem(STORE_KEY);
  if(raw) try { return JSON.parse(raw); } catch(e){}
  return { users: {}, currentUser: null, history: [] };
}
function saveStore(s){ localStorage.setItem(STORE_KEY, JSON.stringify(s)); }

let store = loadStore();

// UTIL
function nowISO(){ return new Date().toISOString(); }
function monthKey(d = new Date()){ return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0'); }

// AUTH
const usernameInput = document.getElementById('usernameInput');
const loginBtn = document.getElementById('loginBtn');
const logoutBtn = document.getElementById('logoutBtn');
const meName = document.getElementById('meName');
const appArea = document.getElementById('appArea');

loginBtn.onclick = ()=>{
  const name = (usernameInput.value||'').trim();
  if(!name){ alert('Bitte Nutzernamen eingeben.'); return; }
  if(!store.users[name]) store.users[name] = { username:name, friends:[], invites:[], receivedInvites:[], challenges:[], active:[] };
  store.currentUser = name;
  saveStore(store);
  renderUI();
}

logoutBtn.onclick = ()=>{
  store.currentUser = null;
  saveStore(store);
  renderUI();
}

// FRIENDS
const friendInput = document.getElementById('friendInput');
const addFriendBtn = document.getElementById('addFriendBtn');
const friendsList = document.getElementById('friendsList');
const friendSelect = document.getElementById('friendSelect');

addFriendBtn.onclick = ()=>{
  const me = store.currentUser;
  if(!me){ alert('Bitte anmelden.'); return; }
  const target = (friendInput.value||'').trim();
  if(!target){ alert('Bitte Freundnamen eingeben.'); return; }
  if(target === me){ alert('Du kannst dich nicht selbst hinzufügen.'); return; }
  // create user if not exist (demo)
  if(!store.users[target]) store.users[target] = { username:target, friends:[], invites:[], receivedInvites:[], challenges:[], active:[] };
  // send invite: push to target.receivedInvites and me.invites for trace
  if(store.users[target].receivedInvites.includes(me)){ alert('Einladung bereits gesendet.'); return; }
  store.users[target].receivedInvites.push(me);
  store.users[me].invites.push({to:target, at: nowISO()});
  store.history = store.history || [];
  store.history.unshift(`${nowISO()}: ${me} hat ${target} eine Freundschaftseinladung gesendet.`);
  saveStore(store);
  friendInput.value = '';
  renderUI();
}

// CHALLENGE
const challengeBtn = document.getElementById('challengeBtn');
const createMsg = document.getElementById('createMsg');

challengeBtn.onclick = ()=>{
  const me = store.currentUser;
  if(!me){ alert('Bitte anmelden.'); return; }
  const to = friendSelect.value;
  if(!to){ alert('Keine Freundin ausgewählt.'); return; }
  // check friend relationship: both must be friends (mutual)
  const meObj = store.users[me];
  const targetObj = store.users[to];
  const mutual = meObj.friends.includes(to) && targetObj.friends.includes(me);
  if(!mutual){ alert('Beide müssen befreundet sein (Einladung akzeptiert).'); return; }
  // monthly limit check (2 per month)
  const mk = monthKey();
  const sentThisMonth = (meObj.challenges || []).filter(c=>c.month===mk).length;
  if(sentThisMonth >= 2){ createMsg.textContent = 'Monatslimit erreicht (2).'; return; }
  // create pending challenge record on target side
  const challenge = { id: 'c_'+Date.now()+'_'+Math.random().toString(36).slice(2,8), from:me, to, at: nowISO(), month: mk, status: 'pending' };
  targetObj.invites = targetObj.invites || [];
  targetObj.invites.push(challenge);
  meObj.challenges = meObj.challenges || [];
  meObj.challenges.push({ ...challenge, status:'sent' });
  store.history = store.history || [];
  store.history.unshift(`${nowISO()}: ${me} hat ${to} eine Quiet-Challenge gesendet.`);
  saveStore(store);
  createMsg.textContent = 'Challenge versendet — Empfänger muss annehmen.';
  renderUI();
}

// Accept / Reject invites & accept challenge
function acceptInvite(inviter){
  const me = store.currentUser;
  if(!me) return;
  // remove from receivedInvites & add to friends both sides
  const meObj = store.users[me];
  if(!meObj.receivedInvites) meObj.receivedInvites = [];
  const idx = meObj.receivedInvites.indexOf(inviter);
  if(idx>=0) meObj.receivedInvites.splice(idx,1);
  if(!meObj.friends.includes(inviter)) meObj.friends.push(inviter);
  const inviterObj = store.users[inviter];
  if(!inviterObj.friends.includes(me)) inviterObj.friends.push(me);
  store.history.unshift(`${nowISO()}: ${me} hat die Einladung von ${inviter} akzeptiert.`);
  saveStore(store);
  renderUI();
}
function rejectInvite(inviter){
  const me = store.currentUser;
  if(!me) return;
  const meObj = store.users[me];
  const idx = meObj.receivedInvites.indexOf(inviter);
  if(idx>=0) meObj.receivedInvites.splice(idx,1);
  store.history.unshift(`${nowISO()}: ${me} hat die Einladung von ${inviter} abgelehnt.`);
  saveStore(store);
  renderUI();
}

function acceptChallenge(ch){
  const me = store.currentUser;
  if(!me) return;
  // find challenge in my invites (object)
  const meObj = store.users[me];
  const itemIndex = (meObj.invites || []).findIndex(x => x.id === ch.id);
  if(itemIndex === -1){ alert('Challenge nicht gefunden.'); return; }
  // mark challenge active for both participants
  const start = Date.now();
  const endsAt = start + 5*60*1000; // 5 minutes
  const active = { id: ch.id, from: ch.from, to: ch.to, startedAt: new Date(start).toISOString(), endsAt: new Date(endsAt).toISOString(), status:'active' };
  meObj.active = meObj.active || [];
  store.users[ch.from].active = store.users[ch.from].active || [];
  meObj.active.push(active);
  store.users[ch.from].active.push(active);
  // remove pending invite entry from meObj.invites
  meObj.invites.splice(itemIndex,1);
  // update sender's record: change corresponding sent challenge to accepted
  const sender = store.users[ch.from];
  if(sender && sender.challenges){
    const sidx = sender.challenges.findIndex(x => x.id === ch.id);
    if(sidx>=0) sender.challenges[sidx].status = 'accepted';
  }
  store.history.unshift(`${nowISO()}: ${me} hat die Challenge von ${ch.from} angenommen. Aktiv bis ${new Date(endsAt).toLocaleTimeString()}.`);
  saveStore(store);
  renderUI();
  // start countdown updates (simple)
  startCountdownForActive(active.id);
}

function rejectChallenge(ch){
  const me = store.currentUser;
  if(!me) return;
  const meObj = store.users[me];
  const idx = (meObj.invites || []).findIndex(x=>x.id===ch.id);
  if(idx>=0) meObj.invites.splice(idx,1);
  // update sender's record
  const sender = store.users[ch.from];
  if(sender && sender.challenges){
    const sidx = sender.challenges.findIndex(x => x.id === ch.id);
    if(sidx>=0) sender.challenges[sidx].status = 'rejected';
  }
  store.history.unshift(`${nowISO()}: ${me} hat die Challenge von ${ch.from} abgelehnt.`);
  saveStore(store);
  renderUI();
}

// Countdown handling
const activeChallengesDiv = document.getElementById('activeChallenges');

function startCountdownForActive(activeId){
  // run an interval that updates UI every second; it will stop when endsAt passes
  if(window._qc_interval_active) return; // single global interval for demo
  window._qc_interval_active = setInterval(()=>{
    // update active lists and remove expired
    let changed = false;
    for(const uname in store.users){
      const u = store.users[uname];
      if(!u.active) continue;
      const now = Date.now();
      const remaining = [];
      for(const a of u.active){
        if(new Date(a.endsAt).getTime() <= now){
          // expire: move to history and remove from both sides
          store.history.unshift(`${nowISO()}: Challenge ${a.id} zwischen ${a.from} → ${a.to} beendet.`);
          // remove a from counterpart too
          const other = store.users[a.from===uname ? a.to : a.from];
          if(other && other.active) other.active = other.active.filter(x=>x.id!==a.id);
          changed = true;
        } else {
          remaining.push(a);
        }
      }
      if(u.active.length !== remaining.length){
        u.active = remaining;
      }
    }
    if(changed) saveStore(store);
    renderUI();
    // stop interval when no active challenges remain
    const anyActive = Object.values(store.users).some(u => (u.active && u.active.length>0));
    if(!anyActive){
      clearInterval(window._qc_interval_active);
      window._qc_interval_active = null;
    }
  }, 1000);
}

// RENDERING
const invitationsDiv = document.getElementById('invitations');
const historyDiv = document.getElementById('history');
const statsDiv = document.getElementById('stats');

function renderUI(){
  // auth
  const me = store.currentUser;
  if(me){
    meName.textContent = me;
    appArea.style.display = 'block';
    logoutBtn.style.display = 'inline-block';
    document.getElementById('authSection').style.display = 'none';
  } else {
    meName.textContent = '—';
    appArea.style.display = 'none';
    logoutBtn.style.display = 'none';
    document.getElementById('authSection').style.display = 'block';
  }

  // friends list for current user
  friendsList.innerHTML = '';
  friendSelect.innerHTML = '<option value="">-- Freund auswählen --</option>';
  invitationsDiv.innerHTML = '';
  activeChallengesDiv.innerHTML = '';
  historyDiv.innerHTML = '';
  statsDiv.textContent = '—';

  for(const uname in store.users){
    // nothing yet
  }

  if(me){
    const meObj = store.users[me];
    // friends list
    if(meObj.friends && meObj.friends.length){
      meObj.friends.forEach(f=>{
        const div = document.createElement('div');
        div.className = 'friend';
        div.innerHTML = `<div><strong>${f}</strong><div class="muted small">befreundet</div></div>
          <div><button class="btn-ghost" data-f="${f}">Entfernen</button></div>`;
        friendsList.appendChild(div);
      });
    } else {
      friendsList.innerHTML = `<div class="muted small">Keine Freunde. Lade welche ein.</div>`;
    }

    // friend select: only mutual friends allowed for challenge
    (meObj.friends || []).forEach(f=>{
      // mutual check
      const fobj = store.users[f] || {};
      if((fobj.friends || []).includes(me)){
        const opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f;
        friendSelect.appendChild(opt);
      }
    });

    // invites (friend invites + challenge invites)
    // show incoming friend invitations
    const inc = meObj.receivedInvites || [];
    inc.forEach(inviter=>{
      const div = document.createElement('div');
      div.className = 'challenge-card';
      div.innerHTML = `<div><strong>${inviter}</strong> möchte dich als Freund hinzufügen.</div>
        <div style="margin-top:8px"><button data-accept="${inviter}" class="btn-ghost">Akzeptieren</button>
        <button data-reject="${inviter}" class="btn-ghost">Ablehnen</button></div>`;
      invitationsDiv.appendChild(div);
    });

    // show incoming challenge invites (objects)
    (meObj.invites || []).forEach(ch=>{
      if(typeof ch === 'string') return; // older format
      const div = document.createElement('div');
      div.className = 'challenge-card';
      div.innerHTML = `<div><strong>${ch.from}</strong> schickt dir eine <em>Quiet-Challenge</em> (5 Minuten).</div>
        <div style="margin-top:8px"><button data-accept-ch="${ch.id}" class="btn-ghost">Annehmen</button>
        <button data-reject-ch="${ch.id}" class="btn-ghost">Ablehnen</button></div>`;
      invitationsDiv.appendChild(div);
    });

    // active challenges for me (where I'm actor or target)
    const act = meObj.active || [];
    if(act.length){
      act.forEach(a=>{
        const rem = Math.max(0, Math.floor((new Date(a.endsAt).getTime() - Date.now())/1000));
        const mm = String(Math.floor(rem/60)).padStart(2,'0');
        const ss = String(rem%60).padStart(2,'0');
        const other = (a.from===me) ? a.to : a.from;
        const role = (a.from===me) ? 'Sender' : 'Empfänger';
        const html = `<div class="challenge-card">
          <div><strong>${a.from}</strong> → <strong>${a.to}</strong></div>
          <div class="muted small">${role} • Endet: ${new Date(a.endsAt).toLocaleTimeString()}</div>
          <div style="margin-top:8px"><span class="timer">${mm}:${ss}</span></div>
        </div>`;
        activeChallengesDiv.insertAdjacentHTML('beforeend', html);
      });
    } else {
      activeChallengesDiv.innerHTML = `<div class="muted small">Keine aktiven Challenges.</div>`;
    }

    // history
    const h = store.history || [];
    historyDiv.innerHTML = h.slice(0,10).map(x=>`<div>${x}</div>`).join('');

    // stats: count sent this month
    const mk = monthKey();
    const sent = (meObj.challenges || []).filter(c=>c.month===mk).length;
    statsDiv.textContent = `Versendet diesen Monat: ${sent} / 2`;
  }

  // attach event handlers for dynamic buttons
  document.querySelectorAll('[data-f]').forEach(btn=>{
    btn.onclick = (e)=>{
      const f = btn.getAttribute('data-f');
      // remove friend both sides
      const me = store.currentUser;
      if(!confirm(`Bist du sicher, ${f} als Freund zu entfernen?`)) return;
      store.users[me].friends = store.users[me].friends.filter(x=>x!==f);
      if(store.users[f]) store.users[f].friends = store.users[f].friends.filter(x=>x!==me);
      store.history.unshift(`${nowISO()}: ${me} hat ${f} entfernt.`);
      saveStore(store);
      renderUI();
    };
  });

  document.querySelectorAll('[data-accept]').forEach(btn=>{
    btn.onclick = ()=> acceptInvite(btn.getAttribute('data-accept'));
  });
  document.querySelectorAll('[data-reject]').forEach(btn=>{
    btn.onclick = ()=> rejectInvite(btn.getAttribute('data-reject'));
  });
  document.querySelectorAll('[data-accept-ch]').forEach(btn=>{
    btn.onclick = ()=>{
      const id = btn.getAttribute('data-accept-ch');
      // find challenge object in my invites
      const ch = (store.users[store.currentUser].invites || []).find(x=>x.id===id);
      if(ch) acceptChallenge(ch);
    };
  });
  document.querySelectorAll('[data-reject-ch]').forEach(btn=>{
    btn.onclick = ()=>{
      const id = btn.getAttribute('data-reject-ch');
      const ch = (store.users[store.currentUser].invites || []).find(x=>x.id===id);
      if(ch) rejectChallenge(ch);
    };
  });
}

// initial render
renderUI();
</script>
</body>
</html>
